## æ€è·¯
å…ˆæ±‚å‡ºæ‰€æœ‰çš„wordsç»„åˆï¼Œå†éå†æ¯”è¾ƒå­—ç¬¦ä¸²çš„æ‰€æœ‰å­ä¸²

### ä»£ç 
```golang
func findSubstring(s string, words []string) []int {
	// æ’é™¤ç‰¹æ®Šæƒ…å†µ
	if len(words) == 0 {
		return nil
	}
	wordLen := len(words[0])
	combLen := len(words) * wordLen
	if len(s) < combLen {
		return nil
	}

	// æ±‚wordsçš„æ‰€æœ‰ç»„åˆ
	var (
		combs   = []string{""}                     // wordsæ‰€æœ‰çš„ç»„åˆ
		counter = make(map[string]int, len(words)) // æ¯ä¸€æ¬¡ç»„åˆä¸­å¯ç”¨çš„wordæ•°é‡
	)
	for i := 0; i < len(words); i++ {
		combsLen := len(combs)
		for j := 0; j < combsLen; j++ {
			comb := combs[j]
			for _, word := range words {
				counter[word]++
			}
			for head := 0; head+wordLen <= len(comb); head += wordLen {
				word := comb[head : head+wordLen]
				counter[word]--
			}

			k := 0
			for _, word := range words {
				if counter[word] > 0 {
					if k == 0 {
						combs[j] = comb + word
					} else {
						combs = append(combs, comb+word)
					}
					k++
					counter[word]--
				}
			}
		}

	}

	// éå†æ¯”è¾ƒæ‰€æœ‰çš„å­å­—ç¬¦ä¸²
	var indices []int
	for head := 0; head+combLen <= len(s); head++ {
		subStr := s[head : head+combLen]
		for _, comb := range combs {
			if comb == subStr {
				indices = append(indices, head)
				break
			}
		}
	}

	return indices
} 
```

**æäº¤ç»“æœï¼š**

![å›¾ç‰‡.png](https://pic.leetcode-cn.com/783f82535fac550e15b8685cd30a69db9b05f95d4fbb21bbfdec4c8aee6b032b-%E5%9B%BE%E7%89%87.png)

è¶…æ—¶äº†ï¼Œéœ€è¦ä¼˜åŒ–ä¸‹

### æ€§èƒ½ä¼˜åŒ–

å› ä¸ºè®¡ç®—wordsç»„åˆçš„æ—¶é—´å¤æ‚åº¦æ˜¯**O(n!)**ï¼Œå¹¶ä¸”æ²¡æœ‰æ·å¾„ï¼Œæ‰€ä»¥åªèƒ½é‡‡ç”¨ä¸€ç§ä¸éœ€è¦è®¡ç®—wordsç»„åˆçš„ç®—æ³•ã€‚
è¿™æ ·ç¬¬ä¸€æƒ³åˆ°çš„æ–¹æ¡ˆå°±æ˜¯å°†`s`çš„å­ä¸²æŒ‰ç…§`words`ä¸­å…ƒç´ çš„é•¿åº¦æ‹†åˆ†ï¼Œé€ä¸ªæ¯”è¾ƒæ‹†åˆ†å‡ºæ¥çš„å…ƒç´ æ˜¯ä¸æ˜¯ç­‰äº`words`ä¸­çš„ä»»ä¸€å…ƒç´ ï¼Œæ˜¯ä¸æ˜¯é‡å¤ç­‰äºæŸä¸ªä¸€ä¸ªå…ƒç´ ã€‚ æŒ‰ç…§è¿™ä¸ªæ€è·¯çš„è¯æœ‰å¦‚ä¸‹ä¼˜åŒ–ç­–ç•¥ï¼š
* æŒ‰ç…§`words`ä¸­å…ƒç´ çš„é•¿åº¦`wordLen`å°†å¯¹æ¯”åˆ†æˆ`wordLen`æ‰¹æ¬¡ï¼›
* åœ¨æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­è‹¥å‘ç°`s`çš„å­ä¸²ä¸­æœ‰çš„å…ƒç´ ä¸ç­‰äº`words`ä¸­ä»»ä¸€å…ƒç´ ï¼Œåˆ™å¯ä»¥ç›´æ¥ä»è¯¥å…ƒç´ åé¢çš„å­ä¸²ç»§ç»­æ¯”è¾ƒï¼Œæ— éœ€æ¯”è¾ƒå‰é¢çš„å­ä¸²ï¼›
* ~~è‹¥æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­å‘ç°å­ä¸²çš„å…ƒç´ é‡å¤ç­‰äº`words`ä¸­çš„æŸä¸€ä¸ªå…ƒç´ ï¼Œåˆ™å¯ä»¥ç›´æ¥è¶Šè¿‡ä¸é‡å¤çš„ä¸€ä¸ªå­ä¸²ä¸­å…ƒç´ ï¼Œç»§ç»­æ¯”è¾ƒä¸‹ä¸€ä¸ªå­ä¸²~~ <!-- è¿™ä¸ªç­–ç•¥æœ‰ç‚¹å¤æ‚ï¼Œè¦è®°å½•ä¸Šä¸€ä¸ªç›¸ç­‰çš„å­ä¸²å…ƒç´ ä½ç½® -->

#### ä»£ç 
```golang
func findSubstring(s string, words []string) []int {
	// æ’é™¤ç‰¹æ®Šæƒ…å†µ
	if len(words) == 0 {
		return nil
	}
	wordLen := len(words[0])
	combLen := len(words) * wordLen
	if len(s) < combLen {
		return nil
	}

	var indices []int
	m := make(map[string]int)
	// åˆ†wordLenæ‰¹æ¬¡æ¯”è¾ƒå­ä¸²
	for i := 0; i < wordLen; i++ {
		j := i
		for j+combLen <= len(s) {
			for _, word := range words {
				m[word]++
			}

			k := j
			step := wordLen
			for k+wordLen <= j+combLen {
				word := s[k : k+wordLen]
				count, ok := m[word]
				// ä¸ç›¸ç­‰åˆ™è·³è¿‡
				if !ok {
					step = k - j + wordLen
					break
				}
				// è¯´æ˜æœ‰é‡å¤ç­‰äºwordsä¸­æŸä¸ªå…ƒç´ çš„æƒ…å†µ
				if count == 0 {
					break
				}
				m[word]--
				k += wordLen
			}
			if k == j+combLen {
				indices = append(indices, j)
			}
			j += step

			for _, word := range words {
				m[word] = 0
			}
		}
	}

	return indices
}
```

**æäº¤ç»“æœ**

![image.png](https://pic.leetcode-cn.com/82ccdb1825d667462dc22db3546246e285251553ce9662c6c1cc76895692e484-image.png)

è™½ç„¶è€—æ—¶ä¸‹é™äº†ï¼Œä½†æ˜¯è¿˜æ˜¯å¾ˆé«˜ï¼Œéœ€è¦å†ç»§ç»­ä¼˜åŒ–ã€‚ğŸ’ª
