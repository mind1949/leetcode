## æ€è·¯
é¢˜ç›®è¦æ±‚åˆå¹¶ä¸¤ä¸ªæœ‰åºçš„é“¾è¡¨ã€‚

ä¾‹å¦‚:
```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```
æƒ³åˆ°çš„æ–¹æ³•æ˜¯ç”¨ç±»ä¼¼å½’å¹¶æ’åºçš„æ–¹æ³•ï¼Œè¿›è¡Œå½’å¹¶æ’åºã€‚

## ä»£ç 
```golang
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	guard := &ListNode{}
	head := guard
	for {
		if l1 == nil {
			head.Next = l2
			break
		}
		if l2 == nil {
			head.Next = l1
			break
		}

		if l1.Val < l2.Val {
			head.Next = &ListNode{
				Val: l1.Val,
			}
			l1 = l1.Next
		} else {
			head.Next = &ListNode{
				Val: l2.Val,
			}
			l2 = l2.Next
		}
        head = head.Next
	}

	return guard.Next
}
```

**æäº¤ç»“æœ**

![å›¾ç‰‡.png](https://pic.leetcode-cn.com/ab7af8232ebd8d794c65b8de85d36d476069c53b7462773405cf0e8a3e412dbd-%E5%9B%BE%E7%89%87.png)

æ•ˆç‡å¤ªä½äº†ï¼Œ éœ€è¦ä¼˜åŒ–ä¸‹ã€‚

### æ€§èƒ½è°ƒä¼˜
å› ä¸ºæˆ‘æ¯åˆå¹¶ä¸€æ¬¡å°±åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œè¿™ä¼šè®©æœ€ç»ˆæ—¶é—´å¤æ‚åº¦ä¸º**O(n)**ï¼Œå…¶ä¸­nä¸ºl1çš„é•¿åº¦åŠ ä¸Šl2çš„é•¿åº¦ã€‚
ä½†æ˜¯å…¶å®æˆ‘å®Œå…¨æ²¡å¿…è¦è¿™æ ·ï¼Œåªè¦å°†l1ä¸l2ä¸­çš„èŠ‚ç‚¹å•ç‹¬æ‹¿å‡ºæ¥æ‹¼æ¥å°±è¡Œäº†ã€‚
æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œä¼˜åŒ–ç»“æœå¦‚ä¸‹ï¼š
```golang
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	guard := &ListNode{}
	head := guard
	for {
		if l1 == nil {
			head.Next = l2
			break
		}
		if l2 == nil {
			head.Next = l1
			break
		}

		if l1.Val < l2.Val {
			node := l1
			l1 = l1.Next
			head.Next = node
		} else {
			node := l2
			l2 = l2.Next
			head.Next = node
		}
		head = head.Next
	}

	return guard.Next
}
````
**ä¼˜åŒ–ç»“æœ**

![å›¾ç‰‡.png](https://pic.leetcode-cn.com/2c79f99f60a480a5443dd3cace3fdddbc83ac4da06094c1ea5c2f8fa0f09aea7-%E5%9B%BE%E7%89%87.png)


æ•ˆæœè¿˜æ˜¯ä¸ç†æƒ³ã€‚ã€‚

å› ä¸ºä¼šæœ‰è¿ç»­ç›¸ç­‰çš„å‡ ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ç”¨å¦‚ä¸‹æ–¹å¼ä¼˜åŒ–ä¸‹ï¼š
```golang
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	guard := &ListNode{}
	head := guard
	for {
		if l1 == nil {
			head.Next = l2
			break
		}
		if l2 == nil {
			head.Next = l1
			break
		}

		if l1.Val < l2.Val {
			v := l1.Val
			for l1 != nil && v == l1.Val {
				node := l1
				l1 = l1.Next
				head.Next = node
				head = head.Next
			}
		} else {
			v := l2.Val
			for l2 != nil && v == l2.Val {
				node := l2
				l2 = l2.Next
				head.Next = node
				head = head.Next
			}
		}
	}

	return guard.Next
}
```
**ä¼˜åŒ–ç»“æœ**

![å›¾ç‰‡.png](https://pic.leetcode-cn.com/f91627949fb71812e6a42baed6d7ee710c729db9146ac8f37261d175ee63759d-%E5%9B%BE%E7%89%87.png)

ç°åœ¨å¿«äº†ç‚¹ğŸ’ª

