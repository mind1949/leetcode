## 思路
最直观的思路是遍历所有的三个元素组合，寻找所有的和为0的组合。
先看看如何遍历所有的组合，再思考如何能优化遍历方式。

先对数组nums进行排序。然后通过升序排序序来帮助减少遍历个数。
通过遍历尝试可以发现，通过固定三元组中间的元素不动，根据每次三个元素的组合的值，来判断下一个组合是移动左右两个元素中的哪一个来迅速的减少需要判断的组合数量。
例如：假设nums的长度为n。若某次次的组合为(l, m, r)，若nums[l]+nums[m]+nums[r] > 0，那么l元素若往右移则肯定更大于零（nums已经通过生序排序），所以此时可以排除掉（l+1到m-1, m, r）这一系列的组合。那么下一步就是看（l, m, r-1）。否则就是排除掉（l, m, r-1到m+1）。

注意：
1. nums数量小于3
2. 三元组合的去重

## 代码实现

```golang
func threeSum(nums []int) [][]int {
	if len(nums) < 3 {
		return nil
	}
	// 升序排序
	sort.IntSlice(nums).Sort()
	if nums[0] > 0 || nums[len(nums)-1] < 0 {
		return nil
	}

	zeros := make([][]int, 0)
	for m := 1; m <= len(nums)-2; m++ {
		l, r := 0, len(nums)-1
		for l < m && r > m {
			sum := nums[l] + nums[m] + nums[r]
			if sum == 0 {
				zero := []int{nums[l], nums[m], nums[r]}
				// 去重
				if !has(zeros, zero) {
					zeros = append(zeros, zero)
				}
			}
			if sum > 0 {
				r--
			} else {
				l++
			}
		}
	}

	return zeros
}

func has(zeros [][]int, zero []int) bool {
	for i := 0; i < len(zeros); i++ {
		pre := zeros[i]
		if pre[0] == zero[0] && pre[1] == zero[1] && pre[2] == zero[2] {
			return true
		}
	}
	return false
}
```